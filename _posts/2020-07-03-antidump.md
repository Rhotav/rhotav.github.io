---
layout: post
author: Rhotav
title: ConfuserEx Deep Analysis ~ AntiDump
---

Selamlar, bu yazımda ConfuserEx adlı "obfuscate" yazılımının içerisindeki AntiDump korumasının derin analizini yapacağım.

### Bu Yazı Neler İçeriyor?
Bu yazı ve "ConfuserEx Deep Analysis" başlığı altında açılan yazılar genel olarak şu başlıklardan oluşacak :
- ConfuserEx Nedir? (*)
- AntiDump Nedir?
- ConfuserEx AntiDump Çalışma Prensibi
- Basit Bir AntiDump Yazalım
- ConfuserEx Anti-AntiDump

## ConfuserEx Nedir?

> ConfuserEx is an free, open-source protector for .NET applications. It is the successor of Confuser project.

> .NET Uygulamaları için bedava, açık kaynaklı bir koruma. "Confuser" projesinin varisidir.

## AntiDump Nedir?

AntiDump, bellekten alınmak istenen dökümü bozan, engelleyen bir yapı. (?)

## ConfuserEx AntiDump Çalışma Prensibi

ConfuserEx korumasının AntiDump'ının çalışma prensibini inceleyebilmek için kodlarını Github sayfasından alalım.
> https://github.com/yck1509/ConfuserEx/blob/master/Confuser.Runtime/AntiDump.cs

 Şundan da bahsetmeliyim ki ConfuserEx, Runtime çalışabilen korumalardan oluşuyor. Yani AntiTamper, AntiDebugger, AntiDump gibi korumalar için Runtime şekilde çalışabilecek korumalar üretiyor ve daha sonrasında seçilen .NET dosyanın içine bunu enjekte edip Rename işlemine sokuyor.
 Örneğin linkini yukarda verdiğim AntiDump.cs dosyası Runtime çalışan (.NET Kütüphaneleri dışında farklı bir kütüphaneye ihtiyaç duymuyor(DLL) ) bir kod parçası.
 > https://github.com/yck1509/ConfuserEx/blob/master/Confuser.Protections/AntiDumpProtection.cs
 
 Bu kısımda gördüğümüz kısım, Runtime çalışan class'ı içerisine enjekte eden kısım :
{% highlight csharp %}
 protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			TypeDef rtType = context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.AntiDump");

			var marker = context.Registry.GetService<IMarkerService>();
			var name = context.Registry.GetService<INameService>();

			foreach (ModuleDef module in parameters.Targets.OfType<ModuleDef>()) {
				IEnumerable<IDnlibDef> members = InjectHelper.Inject(rtType, module.GlobalType, module);

			MethodDef cctor = module.GlobalType.FindStaticConstructor();
			var init = (MethodDef)members.Single(method => method.Name == "Initialize");
			cctor.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Call, init));

			foreach (IDnlibDef member in members)
				name.MarkHelper(member, marker, (Protection)Parent);
}
{% endhighlight %}

Runtime çalışan class'ın DLL Import kısmına bakalım.

{% highlight csharp %}
[DllImport("kernel32.dll")]
static extern unsafe bool VirtualProtect(byte* lpAddress, int dwSize, uint flNewProtect, out uint lpflOldProtect);
{% endhighlight %}
Bu kısımda kernel32.dll 'i içerisinde bulunan VirtualProtect apisi "VirtualProtect" ismi ile class'a dahil ediliyor.
##### VirtualProtect ?
{% highlight cpp %}
BOOL VirtualProtect(
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD  flNewProtect,
  PDWORD lpflOldProtect
);
{% endhighlight %}

> Changes the protection on a region of committed pages in the virtual address space of the calling process.

> Çağrılan işlemin sanal adres alanındaki korumayı değiştirir.

- "lpAddress" : İşaretçi, koruması değiştirilecek alanın başlangıç adresi.
- "dwSize" : Erişim koruma özniteliklerinin değiştirileceği alanın bayt cinsinden boyutu. lpAddress parametresi ve (lpAddress + dwSize) aralığında
- "flNewProtect" : Koruma seçeneği. Daha detaylı bilgi için https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants sayfası ziyaret edilebilir.
- "lpflOldProtect" : Belirtilen adres bölgesindeki ilk adresin önceki erişim koruma değeri.

> https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect


VirtualProtect üstünden de basitçe geçtiğimize göre şimdi kodları inceleyelim.

Initalize method'u içerisindeki kısım yani en başından başlıyoruz.

{% highlight csharp %}
uint old; //1
Module module = typeof(AntiDump).Module; //2
var bas = (byte*)Marshal.GetHINSTANCE(module); //3
//Bunun gerisi memory üzerinde istenilen yerin hesaplanması.
byte* ptr = bas + 0x3c;
byte* ptr2;
ptr = ptr2 = bas + *(uint*)ptr;
ptr += 0x6;
ushort sectNum = *(ushort*)ptr;
ptr += 14;
ushort optSize = *(ushort*)ptr;
ptr = ptr2 = ptr + 0x4 + optSize;
{% endhighlight %}

- uint türünde "old" adlı değişken tanımlanmış. Bunun kullanım amacı VirtualProtect apisinde bulunan "lpflOldProtect" parametresi olacak. out anahtar kelimesi ile parametre gönderilecek.
- "module" değişkenine yüklenen modül aslında programın kendisi. Program runtime şekilde çalıştığından bu şekilde yazılmış
- "bas" adlı değişken, programın memory'deki başlangıç yerini yani MZ Header başlangıç adresini tutuyor. Bunu göstermek istiyorum.
> Örnek bir proje oluşturuyorum Visual Studio'dan ve ConfuserEx'den sadece AntiDump korumasını içerisine enjekte ediyorum. Output olarak "Confused" klasörünün içerisindeki dosyayı dnSpy üzerinde açıp .cctor kısmına gidiyoruz. (Neden buraya gidiyoruz diyecek olursanız Inject Phase kısmında bunu .cctor'a enjekte ettiğini göreceksiniz.)
![Screenshot_1](https://user-images.githubusercontent.com/54905232/86460687-7e67cb00-bd31-11ea-9813-6b931b302002.png)
dnSpy üzerinde açtıktan sonra GetHISTANCE fonksiyonunun çalışmasından hemen sonra olan satıra breakpoint koyuyoruz ve programı yine dnSpy üzerinde debugluyoruz.
![Screenshot_2](https://user-images.githubusercontent.com/54905232/86460940-eb7b6080-bd31-11ea-981f-1766d65e89e0.png)
breakpoint koyduğumuz yere gelince program duruyor ve dnSpy'ın "locals" penceresinden bas adlı değişkenimizin değerine bakınca "0x006A0000" adresini görüyoruz(sizde farklı olacaktır). HxD yazılımını başlatıp "Open Main Memory..." özelliğini kullanarak açılan sekmeden programımızı seçiyoruz.
![Screenshot_3](https://user-images.githubusercontent.com/54905232/86461207-4e6cf780-bd32-11ea-810a-c195b9162290.png)
CTRL + G kombinasyonu sonucunda açılan sekmeye "bas" değişkeninden aldığımız değeri yazıyoruz (0x silmeniz gerekiyor) daha sonra OK tuşuna bastığınızda sizi direkt MZ ascii karakterlerinin olduğu yere götürecek yani en başa.
![Screenshot_4](https://user-images.githubusercontent.com/54905232/86461272-6b092f80-bd32-11ea-80b7-3f4c7c8206d3.png)

